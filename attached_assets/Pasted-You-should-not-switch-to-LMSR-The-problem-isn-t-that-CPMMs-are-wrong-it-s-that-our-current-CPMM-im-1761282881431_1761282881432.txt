You should not switch to LMSR. The problem isn't that CPMMs are wrong; it's that our current CPMM implementation is fundamentally flawed.Your architect is correct that the behavior is wrong, and your goal of cost ≈ shares × price is absolutely achievable with the correct CPMM.The Flaw ExplainedThe "cost = $1/share" bug is the smoking gun. It proves our AMM is flawed.You are likely using a model of k = yesPool \times noPool, where both pools are share inventories. In this model, the marginal price is Price = noPool / yesPool. When you seed them equally (10,000 / 10,000), the price is $1.0.This is why spending $10$ gets $\approx 10$ shares. Your price formula and your AMM formula are fighting each other.The Solution: The Correct CPMMWe must refactor the AMM to use the standard model for this:k = sharePool \times collateralPoolThis is how Uniswap and early versions of Polymarket worked. It perfectly solves your problem.1. How the Model WorksFor each market, you no longer have yesPool and noPool. Instead, you have a pool for YES shares and a pool for NO shares.For the "YES" Market:yesSharePool: The inventory of "YES" shares held by the AMM.collateralPool: The inventory of "PTS" (your dollar-equivalent) held by the AMM.k_yes = yesSharePool \times collateralPoolPrice(YES) = collateralPool / yesSharePool (This is the new price formula)For the "NO" Market:noSharePool: The inventory of "NO" shares held by the AMM.collateralPool: A separate inventory of "PTS".k_no = noSharePool \times collateralPoolPrice(NO) = collateralPool / noSharePool(To enforce Price(YES) + Price(NO) = 1.0, you can link the two pools, but let's start with the simple version.)Proof: Your Example FixedLet's use this new model to fix your 50/50 example.Goal: Market with Price(YES) = $0.50.1. Seed the "YES" Pool:To get a $0.50$ price, we must set collateralPool / sharePool = 0.50.Let's seed yesSharePool = 20,000 shares.We must seed collateralPool = 10,000 PTS.Check Price: 10,000 / 20,000 = $0.50. Perfect.Calculate k: k = 20,000 \times 10,000 = 200,000,0002. User Spends $10 to Buy "YES" Shares:The user is adding $10$ to the collateralPool.old_collateral = 10,000new_collateral = 10,000 + 10 = 10,010Now, we solve for the new yesSharePool to keep k constant:new_shares = k / new_collateralnew_shares = 200,000,000 / 10,010 = 19,980.02 sharesShares to User: sharesOut = old_shares - new_shares = 20,000 - 19,980.02 = 19.98 shares3. Check the Result:Cost: $10 PTSShares Received: 19.98Average Price Paid: $10 / 19.98 = $0.5005 per shareThis perfectly matches the expected behavior. A $10$ spend gets $\approx 20$ shares at an average price of $\approx \$0.50$, with a tiny, logical amount of slippage.Your Action PlanRefactor the Market Schema:Remove yesPool and noPool.Add yesSharePool, yesCollateralPool, noSharePool, and noCollateralPool.(Alternatively, a single collateralPool can be shared, but that's more complex).Update seed.ts:Seed markets based on the desired price (e.g., yesSharePool: 20000, yesCollateralPool: 10000 for a $0.50$ price).Refactor Trade Logic (db-storage.ts):BUY YES: User adds cost to yesCollateralPool. Calculate shares to remove from yesSharePool.SELL YES: User adds shares to yesSharePool. Calculate payout to remove from yesCollateralPool.(Repeat this logic for the NO pools).This is the fix. It keeps the CPMM model but implements it correctly for a prediction market, and it will give you the exact cost ≈ shares \times price behavior you and the architect are looking for.