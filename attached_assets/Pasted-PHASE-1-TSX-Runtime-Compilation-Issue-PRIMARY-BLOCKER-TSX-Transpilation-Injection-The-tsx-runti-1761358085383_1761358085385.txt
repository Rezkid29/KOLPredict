PHASE 1: TSX Runtime Compilation Issue ⚠️ PRIMARY BLOCKER
TSX Transpilation Injection: The tsx runtime automatically injects a __name helper function when transpiling TypeScript code containing function declarations for debugging/stack trace purposes

Browser Context Incompatibility: When page.evaluate() sends the transpiled code to Chromium's V8 engine, the browser context has NO access to Node.js globals like __name

Arrow Function Still Affected: Even using arrow functions () => instead of function declarations, tsx's transpiler still wraps the IIFE pattern (async () => {...})() with __name helpers at lines 180-274

Nested Async Functions Trigger: The complex nested structure (outer arrow returning inner IIFE with multiple helper functions) causes tsx to inject multiple __name references for debugging call stacks

Execution Failure Point: At browser runtime (line <anonymous>:0:35), when the transpiled code executes, it immediately hits ReferenceError: __name is not defined before any scraping logic runs

PHASE 2: Puppeteer Evaluate Serialization
Function Serialization: Puppeteer's page.evaluate() calls .toString() on the provided function, then sends the string representation to the browser

TSX Pre-processing: BEFORE serialization, tsx has already transpiled the TypeScript source, injecting its helpers into the function body

String Contains Helpers: The serialized string sent to browser includes __name(findStatValueByLabel, "findStatValueByLabel") and similar calls

No Polyfill Available: Unlike some Node.js globals that Puppeteer polyfills (like Promise), __name is tsx-specific and has no browser equivalent

Unrecoverable State: Once the code reaches the browser with __name references, there's no way to fix it runtime - the code is fundamentally incompatible

PHASE 3: Stealth Plugin Integration ✅ WORKING
Proper Installation: puppeteer-extra and puppeteer-extra-plugin-stealth are correctly installed and imported at lines 1-2

Plugin Activation: puppeteer.use(StealthPlugin()) successfully registers the stealth modifications before browser launch (line 7)

Browser Fingerprint Masking: The stealth plugin successfully removes navigator.webdriver, patches chrome.runtime, and modifies user-agent to avoid bot detection

Leaderboard Success: The simpler leaderboard scraping (lines 48-150) works perfectly, proving stealth is effective and the site isn't blocking us

Orthogonal Problem: Stealth plugin works correctly but cannot solve the tsx compilation issue - these are separate concerns

PHASE 4: Leaderboard Scraping ✅ WORKING
Simple Evaluate Function: The leaderboard extraction uses a straightforward arrow function returning an object literal (line 76-141)

No Nested Functions: Doesn't define helper functions inside page.evaluate(), avoiding tsx's aggressive __name injection

Successful Extraction: Consistently extracts 20 KOL entries with rank, username, xHandle, wins/losses, SOL gain, USD gain

Selector Strategy Works: Uses querySelectorAll('a[href^="/account/"]') which successfully finds profile links on kolscan.io

Profile URLs Captured: Each entry includes a valid profile URL like /account/CyaE1VxvBrahnPWkqm5VsdCvyS2QmNht2UFrKJHga54o

PHASE 5: Profile Page Scraping ❌ FAILING
Navigation Success: Browser successfully navigates to profile pages (e.g., https://kolscan.io/account/CyaE1VxvBrahnPWkqm5VsdCvyS2QmNht2UFrKJHga54o?timeframe=1)

Page Load Complete: waitUntil: 'networkidle2' completes, indicating page is fully loaded and JavaScript executed

Selector Wait Fails: waitForSelector('main div[class*="grid"] p') times out, suggesting either: (a) page structure different than expected, or (b) content is behind further user interaction

Evaluate Code Injection Fails: At line 180, page.evaluate() is called with the complex async function containing multiple helpers

Immediate ReferenceError: Before any DOM querying happens, the transpiled code tries to execute and hits __name is not defined at character position 35, aborting all profile scraping

Root Cause Summary
The single critical blocker is: TSX runtime injects __name debugging helpers into complex functions passed to page.evaluate(), and these helpers don't exist in browser context.

Required Solution
One of these approaches must be implemented:

Use tsc instead of tsx - Compile the scraper file with TypeScript compiler first, then run with Node
Use ts-node with proper config - Configure to disable name helpers
Extract browser code to string literal - Write the evaluate function as a template string instead of a function
Separate compilation - Put browser-side code in a .js file that's never touched by tsx
Configure tsx with --no-experimental-repl-await or similar flags to reduce helper injection
