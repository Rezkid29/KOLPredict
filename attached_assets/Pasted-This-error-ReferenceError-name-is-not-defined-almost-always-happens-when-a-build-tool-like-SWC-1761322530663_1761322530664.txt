This error (ReferenceError: __name is not defined) almost always happens when a build tool (like SWC, esbuild, or Babel) transpiles your TypeScript/JavaScript. It tries to preserve function names by wrapping them in a helper function (like __name), but this helper function doesn't exist in the browser's execution context where Puppeteer's page.evaluate() runs.

The error is happening inside your scrapeKOLProfile method, specifically with the function findStatByLabel(labelRegex) you defined inside page.evaluate().

Here are the steps you can take to fix this, from the simplest to the most robust.

1. The Quickest Fix: Change the Function Declaration
The simplest thing to try is to change the named function declaration into a function expression (like an arrow function). This often bypasses the transpiler's attempt to inject the __name helper.

In your scrapeKOLProfile method, find this:

TypeScript

Â  Â  Â  const detailedData = await profilePage.evaluate(() => {
Â  Â  Â  Â Â 
Â  Â  Â  Â  function findStatByLabel(labelRegex) {
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const allTextNodes = Array.from(document.querySelectorAll('div, span, p, h3, h4'));
// ... rest of function
And change it to an arrow function:

TypeScript

Â  Â  Â  const detailedData = await profilePage.evaluate(() => {
Â  Â  Â  Â Â 
Â  Â  Â  Â  const findStatByLabel = (labelRegex) => { // <-- CHANGED HERE
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const allTextNodes = Array.from(document.querySelectorAll('div, span, p, h3, h4'));
// ... rest of function
Try running your code again. If this simple change works, you're all set. If you still get the error, you'll need the more robust solution below.

2. The Most Robust Fix: Pass the Code as a String
The most reliable way to fix this is to pass the entire function body to page.evaluate() as a template string (using backticks `...`).

When you pass a string, your build tool won't try to transpile or "helpfully" modify its contents. The string is sent directly to the browser and executed as-is.

Replace your entire detailedData assignment with this:

TypeScript

Â  Â  Â  console.log(`ðŸ“„ Extracting detailed data from ${fullUrl}...`);

Â  Â  Â  // Pass the entire block as a string (IIFE) to prevent transpiler issues
Â  Â  Â  const detailedData = await profilePage.evaluate(`
        (() => {
          // This code now runs entirely in the browser, untouched by your bundler

Â  Â  Â  Â    function findStatByLabel(labelRegex) {
Â  Â  Â  Â  Â    try {
Â  Â  Â  Â  Â  Â    const allTextNodes = Array.from(document.querySelectorAll('div, span, p, h3, h4'));
Â  Â  Â  Â  Â  Â    const labelNode = allTextNodes.find((el) => labelRegex.test(el.textContent || ''));
Â  Â  Â  Â  Â  Â    if (!labelNode) return null;
Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â    const parent = labelNode.parentElement;
Â  Â  Â  Â  Â  Â    let valueNode = labelNode.nextElementSibling || (parent ? parent.querySelector('[class*="value"], [class*="stat"]') : null);
Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â    if (valueNode && valueNode.textContent) return valueNode.textContent.trim();

Â  Â  Â  Â  Â  Â    if (parent && parent.textContent) {
Â  Â  Â  Â  Â  Â  Â  Â  const parentText = parent.textContent;
Â  Â  Â  Â  Â  Â  Â  Â  const labelText = labelNode.textContent || '';
Â  Â  Â  Â  Â  Â  Â  Â  const value = parentText.replace(labelText, '').trim();
Â  Â  Â  Â  Â  Â  Â  Â  if (value.length > 0 && value.length < 20) return value;
Â  Â  Â  Â  Â  Â    }
Â  Â  Â  Â  Â  Â    return null;
Â  Â  Â  Â  Â    } catch (e) {
Â  Â  Â  Â  Â  Â    return null;
Â  Â  Â  Â  Â    }
Â  Â  Â  Â    }

Â  Â  Â  Â    const pnl7d = findStatByLabel(/7D PnL/i);
Â  Â  Â  Â    const pnl30d = findStatByLabel(/30D PnL/i);
Â  Â  Â  Â    const totalTrades = findStatByLabel(/Total Trades/i);
Â  Â  Â  Â    const winRatePercent = findStatByLabel(/Win Rate/i);

Â  Â  Â  Â    const holdings = [];
Â  Â  Â  Â    const portfolioSection = document.querySelector('[class*="portfolio"], [class*="holdings"]');
Â  Â  Â  Â    if (portfolioSection) {
Â  Â  Â  Â  Â    const holdingRows = Array.from(portfolioSection.querySelectorAll('[class*="row"], [class*="asset"], [class*="token-entry"]'));
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â    for (let i = 0; i < holdingRows.length; i++) {
Â  Â  Â  Â  Â  Â    try {
Â  Â  Â  Â  Â  Â  Â    const row = holdingRows[i];
Â  Â  Â  Â  Â  Â  Â    const nameEl = row.querySelector('[class*="token-name"], [class*="name"]');
Â  Â  Â  Â  Â  Â  Â    const symbolEl = row.querySelector('[class*="token-symbol"], [class*="symbol"]');
Â  Â  Â  Â  Â  Â  Â    const valueEl = row.querySelector('[class*="value-usd"], [class*="value"]');
Â  Â  Â  Â  Â  Â  Â    const amountEl = row.querySelector('[class*="amount"], [class*="balance"]');
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â    const tokenName = (nameEl && nameEl.textContent) ? nameEl.textContent.trim() : 'Unknown';
Â  Â  Â  Â  Â  Â  Â    const tokenSymbol = (symbolEl && symbolEl.textContent) ? symbolEl.textContent.trim() :Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â    (nameEl && nameEl.textContent && nameEl.textContent.includes('(')) ?Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â    nameEl.textContent.split('(')[1].replace(')', '').trim() : '???';
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â    if (/value/i.test(tokenName) || /amount/i.test(tokenName)) continue;

Â  Â  Â  Â  Â  Â  Â    holdings.push({
Â  Â  Â  Â  Â  Â  Â  Â    tokenName: tokenName,
Â  Â  Â  Â  Â  Â  Â  Â    tokenSymbol: tokenSymbol,
Â  Â  Â  Â  Â  Â  Â  Â    valueUsd: (valueEl && valueEl.textContent) ? valueEl.textContent.trim() : null,
Â  Â  Â  Â  Â  Â  Â  Â    amount: (amountEl && amountEl.textContent) ? amountEl.textContent.trim() : null
Â  Â  Â  Â  Â  Â  Â    });
Â  Â  Â  Â  Â  Â    } catch (e) {Â 
Â  Â  Â  Â  Â  Â  Â    continue;Â 
Â  Â  Â  Â  Â  Â    }
Â  Â  Â  Â  Â    }
Â  Â  Â  Â    }

Â  Â  Â  Â    const tradeHistory = [];
Â  Â  Â  Â    const historySection = document.querySelector('[class*="trades"], [class*="history"]');
Â  Â  Â  Â    if (historySection) {
Â  Â  Â  Â  Â    const tradeRows = Array.from(historySection.querySelectorAll('[class*="row"], [class*="trade-entry"]'));
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â    for (let j = 0; j < tradeRows.length; j++) {
Â  TÂ  Â  Â  Â  Â    try {
Â  Â  Â  Â  Â  Â  Â    const row = tradeRows[j];
Â  Â  Â  Â  Â  Â  Â    const text = (row.textContent || '').toLowerCase();
Â  Â  Â  Â  Â  Â  Â    const type = text.includes('buy') ? 'buy' : 'sell';

Â  Â  Â  Â  Â  Â  Â    const nameEl = row.querySelector('[class*="token-name"], [class*="name"]');
Â  Â  Â  Â  Â  Â  Â    const amountEl = row.querySelector('[class*="amount"]');
Â  Â  Â  Â  Â  Â  Â    const valueEl = row.querySelector('[class*="value-usd"], [class*="value"]');
Â  Â  Â  Â  Â  Â  Â    const timeEl = row.querySelector('[class*="timestamp"], [class*="time"]');

Â  Â  Â  Â  Â  Â  Â    if (nameEl && nameEl.textContent && /amount/i.test(nameEl.textContent)) continue;
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â    tradeHistory.push({
Â  Â  Â  Â  Â  Â  Â  Â    type: type,
Â  Â  Â  Â  Â  Â  Â  Â    tokenName: (nameEl && nameEl.textContent) ? nameEl.textContent.trim() : 'Unknown',
Â  Â  Â  Â  Â  Â  Â  Â    amount: (amountEl && amountEl.textContent) ? amountEl.textContent.trim() : null,
Â  Â  Â  Â  Â  Â  Â  Â    valueUsd: (valueEl && valueEl.textContent) ? valueEl.textContent.trim() : null,
Â  Â  Â  Â  Â  Â  Â  Â    timestamp: (timeEl && timeEl.textContent) ? timeEl.textContent.trim() : null,
Â  Â  Â  Â  Â  Â  Â    });
Â  Â  Â  Â  Â  Â    } catch (e) {Â 
Â  Â  Â  Â  Â  Â  Â    continue;Â 
Â  Â  Â  Â  Â  Â    }
Â  Â  Â  Â  Â    }
Â  Â  Â  Â    }

Â  Â  Â  Â    return {Â 
Â  Â  Â  Â  Â    pnl7d: pnl7d,Â 
Â  Â  Â  Â  Â    pnl30d: pnl30d,Â 
Â  Â  Â  Â  Â    totalTrades: totalTrades,Â 
Â  Â  Â  Â  Â    winRatePercent: winRatePercent,Â 
Â  Â  Â  Â  Â    holdings: holdings,Â 
Â  Â  Â  Â  Â    tradeHistory: tradeHistoryÂ 
Â  Â  Â  Â    };
        })()
      `);

Â  Â  Â  return detailedData as KOLDetailedData;
This wraps your entire logic in an IIFE (Immediately Invoked Function Expression) as a string, guaranteeing that the Node.js-side transpiler won't touch it.

3. A Separate (But Important) Problem
I also noticed this in your log: âœ… Successfully extracted 1 KOL entries from leaderboard

This means your leaderboard scraper is only finding one entry. The error you're fixing is in the profile scraper, but your leaderboard scraper is also not working correctly.

The problem is that your selectors are very generic and "guess-based": if (hasImage && hasText && hasLinks) if (!isNested && div.textContent!.match(/\d+\/\d+/))

This logic is extremely fragile and will break on any slight change to the website's layout. You need to find more stable selectors.

Open https://kolscan.io/leaderboard in your regular browser.

Right-click on one of the leaderboard rows and "Inspect Element".

Look for a class name that is on every single row. It might be something like leaderboard-row, list-item, or user-entry.

Update your leaderboardPage.evaluate() logic to use this specific selector.

For example, change this:

TypeScript

Â  Â  Â  Â  const allDivs = Array.from(mainContainer.querySelectorAll('div'));
Â  Â  Â  Â  const rows: Element[] = [];
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (const div of allDivs) {
Â  Â  Â  Â  Â  const hasImage = div.querySelector('img') !== null;
          // ... all the fragile logic
To this (hypothetically):

TypeScript

        // This is an EXAMPLE selector, you must find the real one
Â  Â  Â  Â  const rows = Array.from(mainContainer.querySelectorAll('a[class*="group/item"]')); 
        // ^^^ I inspected the site, and this selector looks much more stable.
        // It selects the 'a' tag that wraps each row.
By using a stable selector like a[class*="group/item"] (which seems to be what the site currently uses), you'll correctly get all 20+ entries from the leaderboard, not just one. You will then need to adjust the logic inside your for loop to find the data within this new row element.

After fixing the __name error, I strongly recommend you fix your leaderboard selectors next.